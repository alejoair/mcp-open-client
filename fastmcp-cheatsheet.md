# FastMCP Cheatsheet

## üöÄ ¬øQu√© es MCP y FastMCP?

**Model Context Protocol (MCP)** es un est√°ndar abierto que permite a los LLMs interactuar de forma segura con herramientas externas, datos y servicios. Es como **"USB-C para IA"** - una interfaz universal para conectar cualquier LLM compatible con cualquier fuente de datos o herramienta.

**FastMCP** es un framework de Python que elimina toda la complejidad del protocolo MCP, permiti√©ndote crear servidores MCP escribiendo funciones Python normales.

### ¬øC√≥mo funciona MCP?
1. **Servidor MCP**: Expone herramientas y datos a trav√©s del protocolo
2. **Cliente MCP**: LLMs o aplicaciones que consumen estos recursos
3. **Transporte**: C√≥mo se comunican (STDIO, HTTP)

### Arquitectura MCP
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Cliente   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ Transporte  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  Servidor   ‚îÇ
‚îÇ    (LLM)    ‚îÇ    ‚îÇ (HTTP/STDIO)‚îÇ    ‚îÇ  (FastMCP)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üèóÔ∏è Servidor B√°sico

```python
from fastmcp import FastMCP

# Crear servidor
mcp = FastMCP(name="Mi Servidor")

@mcp.tool
def saludar(nombre: str) -> str:
    """Saluda a una persona por su nombre."""
    return f"¬°Hola, {nombre}!"

if __name__ == "__main__":
    mcp.run()  # STDIO por defecto
```

## üîß Tools (Herramientas)

**¬øQu√© son?** Functions que el LLM puede ejecutar para realizar acciones. Son como endpoints POST de una API - modifican estado, ejecutan c√°lculos, o interact√∫an con sistemas externos.

**¬øCu√°ndo usarlos?** Para cualquier acci√≥n que el LLM necesite realizar:
- C√°lculos matem√°ticos
- Consultas a APIs externas
- Modificar bases de datos
- Generar archivos
- Enviar emails

### Tool con Context y Metadatos
```python
from fastmcp import Context

@mcp.tool(
    name="analizar_archivo",
    description="Analiza un archivo y proporciona estad√≠sticas detalladas",
    tags={"archivos", "analisis", "estadisticas"}
)
async def analizar_archivo(ruta: str, incluir_contenido: bool = False, ctx: Context) -> dict:
    """Analiza un archivo y retorna estad√≠sticas completas."""
    await ctx.info(f"Iniciando an√°lisis de {ruta}")
    
    # Simular an√°lisis progresivo
    await ctx.report_progress(25, 100)
    
    # Leer configuraci√≥n del servidor
    config = await ctx.read_resource("resource://config")
    max_size = config[0].content.get("max_file_size", 1000000)
    
    await ctx.report_progress(50, 100)
    
    # Simular procesamiento
    file_stats = {
        "ruta": ruta,
        "tama√±o_bytes": 2048,
        "lineas": 45,
        "palabras": 320,
        "caracteres": 2048,
        "tipo": "texto",
        "encoding": "utf-8"
    }
    
    if incluir_contenido:
        await ctx.debug("Incluyendo contenido del archivo")
        file_stats["preview"] = "Primera l√≠nea del archivo..."
    
    await ctx.report_progress(100, 100)
    await ctx.info(f"An√°lisis completado para {ruta}")
    
    return file_stats
```

## üìÑ Resources (Recursos)

**¬øQu√© son?** Fuentes de datos de solo lectura que el LLM puede consultar. Son como endpoints GET de una API - proporcionan informaci√≥n sin modificar estado.

**¬øCu√°ndo usarlos?** Para exponer datos que el LLM necesita consultar:
- Configuraciones del sistema
- Estados actuales
- Archivos de referencia
- Documentaci√≥n
- Logs del sistema

**Diferencia con Tools:** Los Resources proporcionan informaci√≥n, los Tools realizan acciones.

### Resource Est√°tico
```python
@mcp.resource("resource://config")
def obtener_config() -> dict:
    """Proporciona la configuraci√≥n de la aplicaci√≥n."""
    return {"version": "1.0", "debug": True}
```

### Resource con Metadatos
```python
@mcp.resource(
    uri="data://status",
    name="Estado del Sistema",
    description="Estado operacional actual",
    mime_type="application/json",
    tags={"sistema", "monitoreo"}
)
def estado_sistema() -> dict:
    return {"estado": "operativo", "uptime": 12345}
```

## üîÄ Resource Templates (Plantillas)

**¬øQu√© son?** Resources din√°micos que generan contenido basado en par√°metros en la URI. Permiten crear "familias" de recursos relacionados.

**¬øCu√°ndo usarlos?** Cuando necesitas exponer datos que var√≠an seg√∫n par√°metros:
- Perfiles de usuarios espec√≠ficos (`users/{id}/profile`)
- Reportes por fecha (`reports/{year}/{month}`)
- Archivos en rutas din√°micas (`files/{path*}`)
- Datos filtrados por categor√≠a

**C√≥mo funcionan:** El LLM solicita `users://123/profile` ‚Üí FastMCP llama `perfil_usuario(user_id="123")`

### Template B√°sico
```python
@mcp.resource("users://{user_id}/profile")
def perfil_usuario(user_id: str) -> dict:
    """Obtiene el perfil de un usuario espec√≠fico."""
    return {"id": user_id, "nombre": f"Usuario {user_id}"}
```

### Template con M√∫ltiples Par√°metros
```python
@mcp.resource("repos://{owner}/{repo}/info")
def info_repositorio(owner: str, repo: str) -> dict:
    """Informaci√≥n de un repositorio GitHub."""
    return {
        "owner": owner,
        "name": repo,
        "full_name": f"{owner}/{repo}"
    }
```

### Template con Wildcards
```python
@mcp.resource("files://{filepath*}")
def contenido_archivo(filepath: str) -> str:
    """Obtiene contenido de cualquier ruta de archivo."""
    return f"Contenido del archivo: {filepath}"
```

## üí¨ Prompts

**¬øQu√© son?** Plantillas de mensajes reutilizables que ayudan a estructurar las instrucciones para el LLM. Son como "snippets" o "macros" para generar prompts consistentes.

**¬øCu√°ndo usarlos?** Para estandarizar interacciones comunes:
- An√°lisis de c√≥digo consistentes
- Formatos de respuesta espec√≠ficos
- Configuraciones de roleplay
- Templates de documentaci√≥n

**Diferencia con Tools/Resources:** Los Prompts no ejecutan c√≥digo ni proporcionan datos, generan instrucciones para el LLM.

### Prompt B√°sico
```python
@mcp.prompt
def analizar_codigo(codigo: str) -> str:
    """Genera prompt para an√°lisis de c√≥digo."""
    return f"Por favor analiza este c√≥digo:\n\n{codigo}"
```

### Prompt con M√∫ltiples Mensajes
```python
from fastmcp.prompts.prompt import Message

@mcp.prompt
def roleplay(personaje: str, situacion: str) -> list[Message]:
    """Configura un escenario de roleplay."""
    return [
        Message(f"Eres {personaje}. Situaci√≥n: {situacion}"),
        Message("Entendido, estoy listo.", role="assistant")
    ]
```

## üèÉ Ejecutar Servidor

**Transportes disponibles:**

### STDIO (Por defecto)
**¬øQu√© es?** Comunicaci√≥n a trav√©s de entrada/salida est√°ndar
**¬øCu√°ndo usar?** Para herramientas locales y clientes como Claude Desktop
```python
mcp.run()  # Para clientes locales como Claude Desktop
```

### HTTP Streamable
**¬øQu√© es?** Comunicaci√≥n HTTP moderna y eficiente
**¬øCu√°ndo usar?** Para servicios web, microservicios, servidores remotos
```python
mcp.run(transport="streamable-http", port=8000)
```

### As√≠ncrono
```python
await mcp.run_async(transport="streamable-http")
```

## üë§ Cliente

**¬øQu√© hace el Cliente?** Se conecta a servidores MCP para usar sus herramientas y recursos. Puede ser un LLM (como Claude) o tu propio c√≥digo Python.

**Flujo t√≠pico:**
1. Conectar al servidor
2. Listar herramientas/recursos disponibles
3. Llamar herramientas con par√°metros
4. Leer recursos por URI

### Cliente B√°sico
```python
import asyncio
from fastmcp import Client

async def main():
    async with Client("mi_servidor.py") as client:
        # Listar tools
        tools = await client.list_tools()
        
        # Llamar tool
        resultado = await client.call_tool("sumar", {"a": 5, "b": 3})
        print(resultado[0].text)

asyncio.run(main())
```

### Cliente Multi-Servidor
**¬øQu√© hace?** Conecta a m√∫ltiples servidores MCP a trav√©s de una configuraci√≥n unificada usando el est√°ndar MCPConfig.

```python
from fastmcp import Client

# Configuraci√≥n para m√∫ltiples servidores
config = {
    "mcpServers": {
        # Servidor remoto HTTP
        "weather": {
            "url": "https://weather-api.example.com/mcp",
            "transport": "streamable-http"
        },
        # Servidor local via stdio
        "assistant": {
            "command": "python",
            "args": ["./assistant_server.py"],
            "env": {"DEBUG": "true"}
        }
    }
}

async def main():
    # Un solo cliente maneja m√∫ltiples servidores
    async with Client(config) as client:
        # Tools con prefijos autom√°ticos del nombre del servidor
        weather = await client.call_tool("weather_get_forecast", {"city": "London"})
        answer = await client.call_tool("assistant_answer_question", {"query": "¬øQu√© es MCP?"})
        
        # Resources con URIs prefijadas
        icons = await client.read_resource("weather://weather/icons/sunny")
        docs = await client.read_resource("resource://assistant/docs/mcp")

asyncio.run(main())
```

## üìù Tipos de Par√°metros

### Tipos B√°sicos
```python
@mcp.tool
def tipos_basicos(
    texto: str,
    numero: int,
    decimal: float,
    booleano: bool
) -> str:
    return "Procesado"
```

### Tipos Opcionales
```python
@mcp.tool
def parametros_opcionales(
    requerido: str,
    opcional: int = 10,
    puede_ser_none: str | None = None
) -> str:
    return "Procesado"
```

### Tipos de Colecci√≥n
```python
@mcp.tool
def colecciones(
    lista: list[str],
    diccionario: dict[str, int],
    conjunto: set[int]
) -> str:
    return "Procesado"
```

### Tipos Literales
```python
from typing import Literal

@mcp.tool
def con_literales(
    modo: Literal["rapido", "lento", "medio"] = "medio"
) -> str:
    return f"Modo: {modo}"
```

### Tipos con Validaci√≥n Pydantic
```python
from typing import Annotated
from pydantic import Field

@mcp.tool
def con_validacion(
    edad: Annotated[int, Field(ge=0, le=120)],
    email: Annotated[str, Field(pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")]
) -> str:
    return "Validado"
```

## üîê Autenticaci√≥n

### Bearer Token (Servidor)
```python
from fastmcp.server.auth import BearerAuthProvider

auth = BearerAuthProvider(
    public_key="your-public-key",
    audience="mi-servidor"
)

mcp = FastMCP(name="Servidor Seguro", auth=auth)
```

## üåê OpenAPI Integration

**¬øQu√© hace?** Convierte autom√°ticamente cualquier API REST con especificaci√≥n OpenAPI en un servidor MCP completo, sin escribir c√≥digo manual.

**Beneficios:**
- Cero duplicaci√≥n de c√≥digo
- Todos los endpoints se vuelven herramientas MCP
- Validaci√≥n autom√°tica de par√°metros
- Documentaci√≥n autom√°tica

### Desde Especificaci√≥n OpenAPI
```python
import httpx

client = httpx.AsyncClient(base_url="https://api.ejemplo.com")
openapi_spec = httpx.get("https://api.ejemplo.com/openapi.json").json()

mcp = FastMCP.from_openapi(
    openapi_spec=openapi_spec,
    client=client,
    name="API Servidor"
)
```

### Desde FastAPI
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/users")
def obtener_usuarios():
    return [{"id": 1, "nombre": "Juan"}]

mcp = FastMCP.from_fastapi(app=app)
```

## üîß CLI Commands

```bash
# Ejecutar servidor
fastmcp run servidor.py

# Modo desarrollo con inspector
fastmcp dev servidor.py

# Instalar en Claude Desktop
fastmcp install servidor.py

# Con dependencias
fastmcp install servidor.py --with pandas --with requests

# Ver versi√≥n
fastmcp version
```

## üõ†Ô∏è Configuraci√≥n Avanzada

### Configuraci√≥n del Servidor
```python
mcp = FastMCP(
    name="Mi Servidor",
    instructions="Instrucciones para el servidor",
    dependencies=["requests", "pandas"],
    include_tags={"publico"},
    exclude_tags={"interno"},
    mask_error_details=True
)
```

### Deshabilitar/Habilitar Componentes
```python
@mcp.tool(enabled=False)
def tool_deshabilitado():
    return "No disponible"

# Program√°ticamente
tool_deshabilitado.enable()
tool_deshabilitado.disable()
```

## üìã Patrones Comunes

### Manejo de Errores
```python
from fastmcp.exceptions import ToolError

@mcp.tool
def dividir(a: float, b: float) -> float:
    if b == 0:
        raise ToolError("No se puede dividir por cero")
    return a / b
```

### Context para Logging
```python
@mcp.tool
async def con_logging(datos: str, ctx: Context) -> str:
    await ctx.info("Iniciando procesamiento")
    await ctx.debug(f"Datos: {datos}")
    await ctx.warning("Advertencia de ejemplo")
    return "Procesado"
```

### Datos Binarios
```python
from fastmcp import Image

@mcp.tool
def generar_imagen() -> Image:
    # ... crear imagen ...
    return Image(data=img_bytes, format="png")
```

## üîç Testing

**¬øPor qu√© testing?** Asegura que tus herramientas y recursos funcionen correctamente antes de exponerlos a LLMs en producci√≥n.

**Ventaja de FastMCP:** Testing in-memory sin necesidad de procesos separados o conexiones de red.

### Test In-Memory
```python
import pytest
from fastmcp import Client

@pytest.fixture
def servidor():
    mcp = FastMCP("Test")
    
    @mcp.tool
    def sumar(a: int, b: int) -> int:
        return a + b
    
    return mcp

async def test_tool(servidor):
    async with Client(servidor) as client:
        resultado = await client.call_tool("sumar", {"a": 2, "b": 3})
        assert resultado[0].text == "5"
```